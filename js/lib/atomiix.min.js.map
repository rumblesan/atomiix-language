{"version":3,"sources":["webpack://atomiix/webpack/universalModuleDefinition","webpack://atomiix/webpack/bootstrap","webpack://atomiix/./node_modules/canto34/dist/canto34.js","webpack://atomiix/./src/language/lexer.js","webpack://atomiix/./src/ast/types.js","webpack://atomiix/./src/ast/index.js","webpack://atomiix/./src/language/scoreParser.js","webpack://atomiix/./src/language/parser.js","webpack://atomiix/./src/transport/osc.js","webpack://atomiix/./src/index.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","_createClass","defineProperties","target","props","length","descriptor","configurable","writable","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","constructor","setPrototypeOf","__proto__","util","lang","isNullOrUndefined","x","extend","arguments","PatternDefinitionException","_Error","message","this","getPrototypeOf","Error","LexerException","_Error2","ParserException","_Error3","Lexer","options","languageName","tokenTypes","tokenType","regexp","consume","RegExp","interpret","push","content","consumed","consumeResult","result","remaining","tracker","LineTracker","tokenTypeLength","somethingFoundThisPass","success","indexOf","line","character","match","exec","index","token","type","ignore","substring","userPartOfString","visibleUserPartOfString","replace","StandardTokenTypes","literal","role","string","parseFloat","parseInt","constant","fail","ch","pos","finished","ch2","unicodeDigits","substr","test","codePoint","codePointString","String","fromCharCode","successResult","Parser","tokens","Array","eof","la1","shift","justSeenSlashR","len","apply","types","canto34","lexer","addTokenType","whitespace","openParen","closeParen","PROGRAM","PLAY","AGENT","SCORE","PERCUSSIVE","MELODIC","CONCRETE","SCOREOPERATOR","SCOREMODIFIER","PANNING","SUSTAIN","ATTACK","ScoreOperator","operator","scoreParser","instrument","scoreString","modifiers","first","charAt","last","slice","matched","concat","scoreChars","scoreType","astTypes","_scoreStringParser","scoreStringParser","chars","durations","offset","instruments","notes","fill","applyModifiers","parsePercussiveScore","_scoreStringParser2","map","parseMelodicScore","_scoreStringParser3","parseConcreteScore","sustain","attack","panning","_loop","modifierType","values","repeats","ast","current","spaces","scoreModifierParser","modifier","split","parser","parse","program","tokenize","initialize","statements","statement","agentName","agent","score","scoreModifiers","scoreOperator","statementToOSC","_ref","patternType","msgArgs","address","args","oscType","OSCMessage","playStmtToOSC","__webpack_exports__","language","transport","toOSC"],"mappings":"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","file":"atomiix.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"atomiix\"] = factory();\n\telse\n\t\troot[\"atomiix\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","(function (global, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([\"exports\"], factory);\n\t} else if (typeof exports !== \"undefined\") {\n\t\tfactory(exports);\n\t} else {\n\t\tvar mod = {\n\t\t\texports: {}\n\t\t};\n\t\tfactory(mod.exports);\n\t\tglobal.canto34 = mod.exports;\n\t}\n})(this, function (exports) {\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\n\tvar _createClass = function () {\n\t\tfunction defineProperties(target, props) {\n\t\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\t\tvar descriptor = props[i];\n\t\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\t\tdescriptor.configurable = true;\n\t\t\t\tif (\"value\" in descriptor) descriptor.writable = true;\n\t\t\t\tObject.defineProperty(target, descriptor.key, descriptor);\n\t\t\t}\n\t\t}\n\n\t\treturn function (Constructor, protoProps, staticProps) {\n\t\t\tif (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t\tif (staticProps) defineProperties(Constructor, staticProps);\n\t\t\treturn Constructor;\n\t\t};\n\t}();\n\n\tfunction _classCallCheck(instance, Constructor) {\n\t\tif (!(instance instanceof Constructor)) {\n\t\t\tthrow new TypeError(\"Cannot call a class as a function\");\n\t\t}\n\t}\n\n\tfunction _possibleConstructorReturn(self, call) {\n\t\tif (!self) {\n\t\t\tthrow new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t\t}\n\n\t\treturn call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t}\n\n\tfunction _inherits(subClass, superClass) {\n\t\tif (typeof superClass !== \"function\" && superClass !== null) {\n\t\t\tthrow new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t\t}\n\n\t\tsubClass.prototype = Object.create(superClass && superClass.prototype, {\n\t\t\tconstructor: {\n\t\t\t\tvalue: subClass,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t}\n\t\t});\n\t\tif (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t}\n\n\tvar util = {\n\t\tlang: {\n\t\t\tisNullOrUndefined: function isNullOrUndefined(x) {\n\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (x === null) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\textend: function extend() {\n\t\t\t// conparable to jquery's extend\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\tfor (var key in arguments[i]) {\n\t\t\t\t\tif (arguments[i].hasOwnProperty(key)) arguments[0][key] = arguments[i][key];\n\t\t\t\t}\n\t\t\t}return arguments[0];\n\t\t}\n\t};\n\n\tvar PatternDefinitionException = function (_Error) {\n\t\t_inherits(PatternDefinitionException, _Error);\n\n\t\tfunction PatternDefinitionException(message) {\n\t\t\t_classCallCheck(this, PatternDefinitionException);\n\n\t\t\treturn _possibleConstructorReturn(this, (PatternDefinitionException.__proto__ || Object.getPrototypeOf(PatternDefinitionException)).call(this, message));\n\t\t}\n\n\t\treturn PatternDefinitionException;\n\t}(Error);\n\n\tvar LexerException = function (_Error2) {\n\t\t_inherits(LexerException, _Error2);\n\n\t\tfunction LexerException(message) {\n\t\t\t_classCallCheck(this, LexerException);\n\n\t\t\treturn _possibleConstructorReturn(this, (LexerException.__proto__ || Object.getPrototypeOf(LexerException)).call(this, message));\n\t\t}\n\n\t\treturn LexerException;\n\t}(Error);\n\n\tvar ParserException = function (_Error3) {\n\t\t_inherits(ParserException, _Error3);\n\n\t\tfunction ParserException(message) {\n\t\t\t_classCallCheck(this, ParserException);\n\n\t\t\treturn _possibleConstructorReturn(this, (ParserException.__proto__ || Object.getPrototypeOf(ParserException)).call(this, message));\n\t\t}\n\n\t\treturn ParserException;\n\t}(Error);\n\n\tvar Lexer = function () {\n\t\tfunction Lexer(options) {\n\t\t\t_classCallCheck(this, Lexer);\n\n\t\t\tvar defaults = {\n\t\t\t\tlanguageName: \"unnamedlanguage\"\n\t\t\t};\n\t\t\tthis.options = util.extend({}, defaults, options);\n\t\t\tthis.tokenTypes = [];\n\t\t}\n\n\t\t_createClass(Lexer, [{\n\t\t\tkey: \"addTokenType\",\n\t\t\tvalue: function addTokenType(tokenType) {\n\n\t\t\t\tif (!tokenType.name) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types must have a 'name' property\");\n\t\t\t\t}\n\n\t\t\t\t// FOR CONSIDERATION: for some tokens, the full 'consume' is required for correct interpretation\n\t\t\t\t// (eg, JSON strings with escaped character) but a regex will do for syntax highlighting. In this\n\t\t\t\t// situation, both are allowed but consume is used for lexing and regexp is used for language definition.\n\t\t\t\t// if (tokenType.regexp && tokenType.consume) {\n\t\t\t\t// \tthrow new canto34.PatternDefinitionException(\"Token types cannot have both a 'regexp' pattern and 'consume' function.\");\n\t\t\t\t// }\n\n\t\t\t\tif (!tokenType.regexp && !tokenType.consume) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types must have a 'regexp' property or a 'consume' function\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.regexp && !(tokenType.regexp instanceof RegExp)) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'regexp' property must be an instance of RegExp\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.consume && typeof tokenType.consume !== \"function\") {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'consume' property must be a function\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.interpret && typeof tokenType.interpret !== \"function\") {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'interpret' property must be a function\");\n\t\t\t\t}\n\t\t\t\tthis.tokenTypes.push(tokenType);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"tokenize\",\n\t\t\tvalue: function tokenize(content) {\n\t\t\t\tif (content === undefined) {\n\t\t\t\t\tthrow new LexerException(\"No content provided\");\n\t\t\t\t}\n\n\t\t\t\tif (this.tokenTypes.length === 0) {\n\t\t\t\t\tthrow new LexerException(\"No token types defined\");\n\t\t\t\t}\n\n\t\t\t\tvar result = [];\n\t\t\t\tvar consumed;\n\t\t\t\tvar remaining = content;\n\t\t\t\tvar tracker = new LineTracker();\n\t\t\t\tvar tokenTypeLength = this.tokenTypes.length;\n\t\t\t\tvar consumeResult;\n\n\t\t\t\twhile (remaining.length > 0) {\n\t\t\t\t\tvar somethingFoundThisPass = false;\n\n\t\t\t\t\tfor (var i = 0; i < tokenTypeLength; i++) {\n\t\t\t\t\t\tvar tokenType = this.tokenTypes[i];\n\n\t\t\t\t\t\tconsumeResult = undefined;\n\t\t\t\t\t\tif (tokenType.consume) {\n\t\t\t\t\t\t\t// must have a consume function;\n\t\t\t\t\t\t\tconsumeResult = tokenType.consume(remaining);\n\t\t\t\t\t\t\t// should have told us what it consumed;\n\t\t\t\t\t\t\tif (consumeResult.success) {\n\t\t\t\t\t\t\t\tif (remaining.indexOf(consumeResult.consumed) !== 0) {\n\t\t\t\t\t\t\t\t\tthrow new LexerException(\"The consume function for \" + tokenType.name + \" failed to return the start of the remaining content at \" + tracker.line + \".\" + tracker.character + \" and instead returned \" + consumeResult.consumed);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsomethingFoundThisPass = true;\n\t\t\t\t\t\t\t\t\tconsumed = consumeResult.consumed;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar match = tokenType.regexp.exec(remaining);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\t// we found a token! great. What did it say? We only\n\t\t\t\t\t\t\t\t// want to match at the start of the string\n\t\t\t\t\t\t\t\tif (match.index === 0) {\n\t\t\t\t\t\t\t\t\tsomethingFoundThisPass = true;\n\t\t\t\t\t\t\t\t\tconsumed = match[0];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//handle our new token\n\t\t\t\t\t\tif (tokenType.interpret) {\n\t\t\t\t\t\t\tcontent = tokenType.interpret(consumed);\n\t\t\t\t\t\t} else if (consumeResult && !util.lang.isNullOrUndefined(consumeResult.content)) {\n\t\t\t\t\t\t\tcontent = consumeResult.content;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent = consumed;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = {\n\t\t\t\t\t\t\tcontent: content,\n\t\t\t\t\t\t\ttype: tokenType.name,\n\t\t\t\t\t\t\tline: tracker.line,\n\t\t\t\t\t\t\tcharacter: tracker.character\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!tokenType.ignore) {\n\t\t\t\t\t\t\tresult.push(token);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremaining = remaining.substring(consumed.length);\n\t\t\t\t\t\ttracker.consume(consumed);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!somethingFoundThisPass) {\n\t\t\t\t\t\tvar userPartOfString = remaining.substring(0, 15);\n\t\t\t\t\t\tvar visibleUserPartOfString = userPartOfString.replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\").replace(\"\\n\", \"\\\\n\");\n\t\t\t\t\t\tthrow new LexerException(\"No viable alternative at \" + tracker.line + \".\" + tracker.character + \": '\" + visibleUserPartOfString + \"...'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}]);\n\n\t\treturn Lexer;\n\t}();\n\n\tfunction escapeRegExp(string) {\n\t\treturn string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n\t}\n\n\tvar StandardTokenTypes = function () {\n\t\tfunction StandardTokenTypes() {\n\t\t\t_classCallCheck(this, StandardTokenTypes);\n\t\t}\n\n\t\t_createClass(StandardTokenTypes, null, [{\n\t\t\tkey: \"constant\",\n\t\t\tvalue: function constant(literal, name, role) {\n\t\t\t\trole = role || [\"keyword\"];\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\tregexp: new RegExp(\"^\" + escapeRegExp(literal)),\n\t\t\t\t\trole: role\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"floatingPoint\",\n\t\t\tvalue: function floatingPoint() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"floating point\",\n\t\t\t\t\tregexp: /(^-?\\d*\\.\\d+)/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"],\n\t\t\t\t\tinterpret: function interpret(content) {\n\t\t\t\t\t\treturn parseFloat(content);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"integer\",\n\t\t\tvalue: function integer() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"integer\",\n\t\t\t\t\tregexp: /^-?\\d+/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"],\n\t\t\t\t\tinterpret: function interpret(content) {\n\t\t\t\t\t\treturn parseInt(content);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"whitespace\",\n\t\t\tvalue: function whitespace() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"whitespace\",\n\t\t\t\t\tignore: true,\n\t\t\t\t\tregexp: /^[ \\t]+/\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"whitespaceWithNewlines\",\n\t\t\tvalue: function whitespaceWithNewlines() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"whitespace\",\n\t\t\t\t\tignore: true,\n\t\t\t\t\tregexp: /^[ \\t\\r\\n]+/\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"real\",\n\t\t\tvalue: function real() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"real number\",\n\t\t\t\t\tregexp: /^X/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"]\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"comma\",\n\t\t\tvalue: function comma() {\n\t\t\t\treturn this.constant(\",\", \"comma\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"period\",\n\t\t\tvalue: function period() {\n\t\t\t\treturn this.constant(\".\", \"period\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"star\",\n\t\t\tvalue: function star() {\n\t\t\t\treturn this.constant(\"*\", \"star\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"colon\",\n\t\t\tvalue: function colon() {\n\t\t\t\treturn this.constant(\":\", \"colon\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openParen\",\n\t\t\tvalue: function openParen() {\n\t\t\t\treturn this.constant(\"(\", \"open paren\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeParen\",\n\t\t\tvalue: function closeParen() {\n\t\t\t\treturn this.constant(\")\", \"close paren\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openBracket\",\n\t\t\tvalue: function openBracket() {\n\t\t\t\treturn this.constant(\"{\", \"open bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeBracket\",\n\t\t\tvalue: function closeBracket() {\n\t\t\t\treturn this.constant(\"}\", \"close bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openSquareBracket\",\n\t\t\tvalue: function openSquareBracket() {\n\t\t\t\treturn this.constant(\"[\", \"open square bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeSquareBracket\",\n\t\t\tvalue: function closeSquareBracket() {\n\t\t\t\treturn this.constant(\"]\", \"close square bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"JsonString\",\n\t\t\tvalue: function JsonString() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"string\",\n\t\t\t\t\tregexp: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\t\t\tconsume: function consume(remaining) {\n\t\t\t\t\t\tvar fail = { success: false };\n\t\t\t\t\t\tif (remaining.indexOf('\"') !== 0) {\n\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar content = '';\n\t\t\t\t\t\tvar pos = 1;\n\t\t\t\t\t\tvar ch;\n\t\t\t\t\t\tvar finished = false;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tch = remaining[pos];\n\t\t\t\t\t\t\tpos += 1;\n\n\t\t\t\t\t\t\tswitch (ch) {\n\t\t\t\t\t\t\t\tcase '\"':\n\t\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\t\t\t\tvar ch2 = remaining[pos];\n\t\t\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\t\t\tswitch (ch2) {\n\t\t\t\t\t\t\t\t\t\tcase '\"':\n\t\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t\tcase \"t\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\t\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"r\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\r\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"n\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\n\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"u\":\n\t\t\t\t\t\t\t\t\t\t\tvar unicodeDigits = remaining.substr(pos, 4);\n\t\t\t\t\t\t\t\t\t\t\tif (unicodeDigits.length != 4 || !/\\d{4}/.test(unicodeDigits)) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\\\u\";\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tpos += 4;\n\t\t\t\t\t\t\t\t\t\t\t\tvar codePoint = parseInt(unicodeDigits, 10);\n\t\t\t\t\t\t\t\t\t\t\t\tvar codePointString = String.fromCharCode(codePoint);\n\t\t\t\t\t\t\t\t\t\t\t\tcontent += codePointString;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t// something like \\q, which doesn't mean anything\n\t\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcontent += ch;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!finished);\n\n\t\t\t\t\t\tvar consumed = remaining.substring(0, pos);\n\n\t\t\t\t\t\tvar successResult = {\n\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\tconsumed: consumed,\n\t\t\t\t\t\t\tcontent: content\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn successResult;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}]);\n\n\t\treturn StandardTokenTypes;\n\t}();\n\n\tvar Parser = function () {\n\t\tfunction Parser() {\n\t\t\t_classCallCheck(this, Parser);\n\t\t}\n\n\t\t_createClass(Parser, [{\n\t\t\tkey: \"initialize\",\n\t\t\tvalue: function initialize(tokens) {\n\t\t\t\tif (!tokens) {\n\t\t\t\t\tthrow new ParserException(\"No tokens provided to the parser\");\n\t\t\t\t}\n\n\t\t\t\tif (!(tokens instanceof Array)) {\n\t\t\t\t\tthrow new ParserException(\"A non-array was provided to the parser instead of a token array\");\n\t\t\t\t}\n\n\t\t\t\tthis.tokens = tokens;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"la1\",\n\t\t\tvalue: function la1(tokenType) {\n\t\t\t\tif (this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"No tokens available\");\n\t\t\t\t}\n\n\t\t\t\treturn this.tokens[0].type == tokenType;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"match\",\n\t\t\tvalue: function match(tokenType) {\n\n\t\t\t\tif (this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"Expected \" + tokenType + \" but found EOF\");\n\t\t\t\t}\n\n\t\t\t\tif (!this.la1(tokenType)) {\n\t\t\t\t\tthrow new ParserException(\"Expected \" + tokenType + \" but found \" + this.tokens[0].type + \" at l\" + this.tokens[0].line + \".\" + this.tokens[0].character);\n\t\t\t\t}\n\n\t\t\t\treturn this.tokens.shift();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"eof\",\n\t\t\tvalue: function eof() {\n\t\t\t\treturn this.tokens.length === 0;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"expectEof\",\n\t\t\tvalue: function expectEof() {\n\t\t\t\tif (!this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"Expected EOF but found \" + this.tokens[0].type + \" at l\" + this.tokens[0].line + \".\" + this.tokens[0].character);\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\n\t\treturn Parser;\n\t}();\n\n\tvar LineTracker = function () {\n\t\tfunction LineTracker() {\n\t\t\t_classCallCheck(this, LineTracker);\n\n\t\t\tthis.line = 1;\n\t\t\tthis.character = 1;\n\t\t\tthis.justSeenSlashR = false;\n\t\t}\n\n\t\t_createClass(LineTracker, [{\n\t\t\tkey: \"consume\",\n\t\t\tvalue: function consume(content) {\n\n\t\t\t\tfor (var i = 0, len = content.length; i < len; i++) {\n\t\t\t\t\tif (content[i] == \"\\r\") {\n\t\t\t\t\t\tthis.line += 1;\n\t\t\t\t\t\tthis.character = 1;\n\t\t\t\t\t\tthis.justSeenSlashR = true;\n\t\t\t\t\t} else if (content[i] == \"\\n\") {\n\t\t\t\t\t\tif (!this.justSeenSlashR) {\n\t\t\t\t\t\t\tthis.line += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.character = 1;\n\t\t\t\t\t\tthis.justSeenSlashR = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.character += 1;\n\t\t\t\t\t\tthis.justSeenSlashR = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\n\t\treturn LineTracker;\n\t}();\n\n\texports.PatternDefinitionException = PatternDefinitionException;\n\texports.LexerException = LexerException;\n\texports.ParserException = ParserException;\n\texports.Lexer = Lexer;\n\texports.StandardTokenTypes = StandardTokenTypes;\n\texports.Parser = Parser;\n\texports.LineTracker = LineTracker;\n});","import * as canto34 from 'canto34';\n\nconst types = canto34.StandardTokenTypes;\n\nconst lexer = new canto34.Lexer({ languageName: 'atomiix' });\n\nconst comment = () => ({\n  name: 'comment',\n  ignore: true,\n  regexp: /^\\/\\/[^\\n]*/,\n});\n\nconst newline = () => ({\n  name: 'newline',\n  regexp: /^\\n[ \\n]*/,\n});\n\nconst identifier = () => ({\n  name: 'identifier',\n  regexp: /^[a-zA-Z][a-zA-Z0-9]*/,\n});\n\nconst score = () => ({\n  name: 'score',\n  regexp: /^[{[\\\\|][a-zA-Z0-9 ]*[}\\]\\\\|]/,\n});\n\nconst scoreModifier = () => ({\n  name: 'score modifier',\n  regexp: /^[<\\\\^][Z0-9 ]*[>\\\\^]/,\n});\n\nconst operator = () => ({\n  name: 'operator',\n  regexp: /^[*/+-]+/,\n});\n\nconst number = () => ({\n  name: 'number',\n  regexp: /^\\d+(\\.\\d+)?/,\n  role: ['constant', 'numeric'],\n  interpret(content) {\n    return parseFloat(content);\n  },\n});\n\nlexer.addTokenType(types.whitespace());\nlexer.addTokenType(newline());\nlexer.addTokenType(comment());\n\nlexer.addTokenType(types.constant('->', 'play arrow'));\nlexer.addTokenType(types.constant('>>', 'add effect arrow'));\nlexer.addTokenType(types.constant('<<', 'remove effect arrow'));\n\nlexer.addTokenType(types.openParen());\nlexer.addTokenType(types.closeParen());\n\nlexer.addTokenType(operator());\n\nlexer.addTokenType(number());\n\nlexer.addTokenType(identifier());\nlexer.addTokenType(score());\nlexer.addTokenType(scoreModifier());\n\nexport default lexer;\n","export const PROGRAM = 'PROGRAM';\n\nexport const PLAY = 'PLAY';\nexport const FXCHAIN = 'FXCHAIN';\n\nexport const AGENT = 'AGENT';\n\nexport const SCORE = 'SCORE';\nexport const PERCUSSIVE = 'PERCUSSIVE';\nexport const MELODIC = 'MELODIC';\nexport const CONCRETE = 'CONCRETE';\n\nexport const SCOREOPERATOR = 'SCOREOPERATOR';\n\nexport const SCOREMODIFIER = 'SCOREMODIFIER';\nexport const PANNING = 'PANNING';\nexport const SUSTAIN = 'SUSTAIN';\nexport const ATTACK = 'ATTACK';\n\nexport const EFFECT = 'EFFECT';\n","import {\n  PROGRAM,\n  PLAY,\n  FXCHAIN,\n  AGENT,\n  SCORE,\n  SCOREOPERATOR,\n  SCOREMODIFIER,\n  EFFECT,\n} from './types';\n\n/**\n *  value: [Statement]\n */\nexport function Program(statements) {\n  return {\n    type: PROGRAM,\n    statements,\n  };\n}\n\n/**\n *  agent: Agent\n *  score: Score\n */\nexport function Play(agent, score) {\n  return {\n    type: PLAY,\n    agent,\n    score,\n  };\n}\n\n/**\n *  agent: Agent\n *  effects: [Effect]\n */\nexport function FXChain(agent, effects) {\n  return {\n    type: FXCHAIN,\n    agent,\n    effects,\n  };\n}\n\n/**\n *  name: Identifier\n */\nexport function Agent(name) {\n  return {\n    type: AGENT,\n    name,\n  };\n}\n\n/**\n *  scoreType: ScoreType\n *  instruments: [string]\n *  notes: [string | integer]\n *  durations: [integer]\n *  offset: integer\n */\nexport function Score(\n  scoreType,\n  notes,\n  durations,\n  instruments,\n  sustain,\n  attack,\n  panning,\n  offset,\n  repeats\n) {\n  return {\n    type: SCORE,\n    scoreType,\n    notes,\n    durations,\n    instruments,\n    sustain,\n    attack,\n    panning,\n    offset,\n    repeats,\n  };\n}\n\n/**\n *  operator: string\n *  value: float\n */\nexport function ScoreOperator(operator, value) {\n  return {\n    type: SCOREOPERATOR,\n    operator,\n    value,\n  };\n}\n\n/**\n *  modifierType: ScoreModifier\n *  values: [integer]\n */\nexport function ScoreModifier(modifierType, values) {\n  return {\n    type: SCOREMODIFIER,\n    modifierType,\n    values,\n  };\n}\n\n/**\n *  name: Identifier\n */\nexport function Effect(name) {\n  return {\n    type: EFFECT,\n    name,\n  };\n}\n","import { ParserException } from 'canto34';\n\nimport * as ast from '../ast';\nimport * as astTypes from '../ast/types';\n\n// TODO\n// use modifiers\nexport function scoreParser(instrument, scoreString, modifiers) {\n  const first = scoreString.charAt(0);\n  const last = scoreString.slice(-1);\n\n  let matched = false;\n  switch (first) {\n    case '|':\n      matched = last === '|';\n      break;\n    case '[':\n      matched = last === ']';\n      break;\n    case '{':\n      matched = last === '}';\n      break;\n  }\n  if (!matched) {\n    throw new ParserException(\n      `Score delimiters don't match. Starts with ${first} but ends with ${last}`\n    );\n  }\n\n  const scoreChars = scoreString.slice(1, -1);\n  switch (first) {\n    case '|':\n      if (instrument) {\n        throw new ParserException(\n          `Percussive score shouldn't have instrument: ${instrument}`\n        );\n      }\n      return parsePercussiveScore(scoreChars, modifiers);\n    case '[':\n      return parseMelodicScore(instrument, scoreChars, modifiers);\n    case '{':\n      return parseConcreteScore(instrument, scoreChars, modifiers);\n    default:\n      throw new ParserException(`${first} is not a supported score delimiters`);\n  }\n}\n\nexport function parsePercussiveScore(scoreChars, modifiers) {\n  const scoreType = astTypes.PERCUSSIVE;\n  const { chars, durations, offset } = scoreStringParser(scoreChars);\n  const instruments = chars;\n  const notes = Array(chars.length).fill(60);\n  return applyModifiers(\n    scoreType,\n    notes,\n    durations,\n    instruments,\n    offset,\n    modifiers\n  );\n}\n\nexport function parseMelodicScore(instrument, scoreChars, modifiers) {\n  const scoreType = astTypes.MELODIC;\n  const { chars, durations, offset } = scoreStringParser(scoreChars);\n  const notes = chars.map(c => parseInt(c, 10));\n  return applyModifiers(\n    scoreType,\n    notes,\n    durations,\n    [instrument],\n    offset,\n    modifiers\n  );\n}\n\nexport function parseConcreteScore(instrument, scoreChars, modifiers) {\n  const scoreType = astTypes.CONCRETE;\n  const { chars, durations, offset } = scoreStringParser(scoreChars);\n  const notes = chars.map(c => parseInt(c, 10));\n  return applyModifiers(\n    scoreType,\n    notes,\n    durations,\n    [instrument],\n    offset,\n    modifiers\n  );\n}\n\nexport function applyModifiers(\n  scoreType,\n  notes,\n  durations,\n  instruments,\n  offset,\n  modifiers\n) {\n  let sustain = [];\n  let attack = [];\n  let panning = [];\n  let repeats = 'inf';\n\n  for (let i = 0; i < modifiers.length; i += 1) {\n    const m = modifiers[i];\n    if (m.type === astTypes.SCOREMODIFIER) {\n      switch (m.modifierType) {\n        case astTypes.PANNING:\n          panning = m.values;\n          break;\n        case astTypes.SUSTAIN:\n          sustain = m.values;\n          break;\n        case astTypes.ATTACK:\n          attack = m.values;\n          break;\n      }\n    } else if (m.type === astTypes.SCOREOPERATOR) {\n      // TODO handle * and / operators\n      switch (m.operator) {\n        case '+':\n          notes = notes.map(n => n + m.value);\n          break;\n        case '-':\n          notes = notes.map(n => n - m.value);\n          break;\n      }\n    }\n  }\n  return ast.Score(\n    scoreType,\n    notes,\n    durations,\n    instruments,\n    sustain,\n    attack,\n    panning,\n    offset,\n    repeats\n  );\n}\n\nexport function scoreStringParser(scoreChars) {\n  const chars = [];\n  const durations = [];\n  let offset = 0;\n\n  let current = '';\n  let spaces = 0;\n\n  for (let i = 0; i < scoreChars.length; i += 1) {\n    const c = scoreChars[i];\n    if (c === ' ') {\n      spaces += 1;\n      continue;\n    }\n    if (current === '') {\n      offset = spaces;\n    } else {\n      chars.push(current);\n      durations.push(spaces);\n    }\n    current = c;\n    spaces = 1;\n  }\n\n  if (current != '') {\n    chars.push(current);\n    durations.push(spaces);\n  }\n  return {\n    chars,\n    durations,\n    offset,\n  };\n}\n\nexport function scoreModifierParser(modifier) {\n  const first = modifier.charAt(0);\n  const last = modifier.slice(-1);\n\n  let modifierType;\n  let matched = false;\n  switch (first) {\n    case '<':\n      modifierType = astTypes.PANNING;\n      matched = last === '>';\n      break;\n    case '^':\n      modifierType = astTypes.ATTACK;\n      matched = last === '^';\n      break;\n  }\n  if (!matched) {\n    throw new ParserException(\n      `Score modifier delimiters don't match. Starts with ${first} but ends with ${last}`\n    );\n  }\n\n  const smString = modifier.slice(1, -1);\n  const values = smString.split('').map(c => parseInt(c, 10));\n\n  return ast.ScoreModifier(modifierType, values);\n}\n","import { ParserException, Parser } from 'canto34';\n\nimport lexer from './lexer';\n\nimport * as ast from '../ast';\n\nimport { scoreParser, scoreModifierParser } from './scoreParser';\n\nconst parser = new Parser();\n\nparser.parse = function(program) {\n  const tokens = lexer.tokenize(program);\n  this.initialize(tokens);\n  return this.program();\n};\n\nparser.program = function() {\n  const statements = [];\n  while (!this.eof()) {\n    if (this.la1('newline')) {\n      this.match('newline');\n    } else {\n      statements.push(this.statement());\n    }\n  }\n  return ast.Program(statements);\n};\n\nparser.statement = function() {\n  if (this.la1('tempo')) {\n    throw new ParserException(\"Don't support tempo changes yet\");\n  }\n  if (this.la1('tonic')) {\n    throw new ParserException(\"Don't support tonic changes yet\");\n  }\n  if (this.la1('scale')) {\n    throw new ParserException(\"Don't support scale changes yet\");\n  }\n  if (this.la1('grid')) {\n    throw new ParserException(\"Don't support grid changes yet\");\n  }\n  if (this.la1('group')) {\n    throw new ParserException(\"Don't support grid changes yet\");\n  }\n\n  const agentName = ast.Agent(this.match('identifier').content);\n\n  if (this.la1('play arrow')) {\n    this.match('play arrow');\n    const score = this.score();\n    return ast.Play(agentName, score);\n  } else if (this.la1('add effect arrow')) {\n    throw new ParserException(\"Don't support adding effects yet\");\n  } else if (this.la1('remove effect arrow')) {\n    throw new ParserException(\"Don't support removing effects yet\");\n  }\n};\n\nparser.score = function() {\n  let instrument = '';\n  if (this.la1('identifier')) {\n    instrument = this.match('identifier').content;\n  }\n  const scoreString = this.match('score').content;\n\n  const modifiers = this.scoreModifiers();\n\n  return scoreParser(instrument, scoreString, modifiers);\n};\n\n// TODO\n// handle the following modifiers\n// * note length\n// * whatever the tilde does\nparser.scoreModifiers = function() {\n  const modifiers = [];\n  while (!this.eof() && !this.la1('newline')) {\n    if (this.la1('operator')) {\n      const operator = this.scoreOperator();\n      modifiers.push(operator);\n    } else if (this.la1('score modifier')) {\n      const modifier = scoreModifierParser(\n        this.match('score modifier').content\n      );\n      modifiers.push(modifier);\n    } else {\n      throw new ParserException(\n        'Unexpected token: Expecting operator or score modifier'\n      );\n    }\n  }\n  return modifiers;\n};\n\nparser.scoreOperator = function() {\n  const operator = this.match('operator').content;\n  const number = this.match('number').content;\n  return ast.ScoreOperator(operator, number);\n};\n\nparser.scoreOperator = function() {\n  const operator = this.match('operator').content;\n  const number = this.match('number').content;\n  return ast.ScoreOperator(operator, number);\n};\n\nexport default parser;\n","import * as t from '../ast/types';\n\nfunction OSCMessage(address, args) {\n  return {\n    oscType: 'message',\n    address,\n    args,\n  };\n}\n\nexport function programToOSC(program) {\n  return program.statements.map(statementToOSC);\n}\n\nexport function statementToOSC(statement) {\n  switch (statement.type) {\n    case t.PLAY:\n      return playStmtToOSC(statement);\n  }\n}\n\nexport function playStmtToOSC({ agent, score }) {\n  const address = '/play/pattern';\n  let patternType;\n  switch (score.scoreType) {\n    case t.PERCUSSIVE:\n      patternType = 'percussive';\n      break;\n    case t.MELODIC:\n      patternType = 'melodic';\n      break;\n    case t.CONCRETE:\n      patternType = 'concrete';\n      break;\n  }\n  const repeats =\n    score.repeats === 'inf'\n      ? { type: 'bang' }\n      : { type: 'integer', value: score.repeats };\n  const msgArgs = [\n    agent.name, // agentName\n    patternType, // patternType\n    { type: 'array', value: score.notes }, // noteArray\n    { type: 'array', value: score.durations }, // durArray\n    { type: 'array', value: score.instruments }, // instrumentArray\n    { type: 'array', value: score.sustain }, // sustainArray\n    { type: 'array', value: score.attack }, // attackArray\n    { type: 'array', value: score.panning }, // panArray\n    score.offset, // quantPhase,\n    repeats, // repeats\n  ];\n  return OSCMessage(address, msgArgs);\n}\n","import parser from 'language/parser';\nimport { programToOSC } from 'transport/osc';\n\nconst language = 'atomiix';\n\nexport default {\n  language,\n  parser,\n  transport: {\n    toOSC: programToOSC,\n  },\n};\n"],"sourceRoot":""}